---
layout: vue3
title: vue3 相关存档
date: 2025-08-04 10:30:10
tags: vue3 pina router
---
你以为的你已经很了解了，每次读官方文档，都会有不一样的东西，让你眼前一亮。
## vue3 
Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。
> 提供了 `选项式` API 和 `组合式` API 两种编程模型

<!-- more -->

#### 响应式基础

+ ##### **`ref()`**

----

在组合式 API 中，推荐使用 `ref()` 函数来声明响应式状态：

```javascript
import { ref } from 'vue'

const count = ref(0)
```

`ref()` 接收参数，并将其包裹在一个带有 .value 属性的 ref 对象中返回：

```javascript
const count = ref(0)

console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

要在组件模板中访问 ref，请从组件的 setup() 函数中声明并返回它们：


```javascript
import { ref } from 'vue'

export default {
  // `setup` 是一个特殊的钩子，专门用于组合式 API。
  setup() {
    const count = ref(0)

    // 将 ref 暴露给模板
    return {
      count
    }
  }
}
```

```html
<div>{{ count }}</div>
```

> 注意，在模板中使用 ref 时，我们不需要附加 .value。为了方便起见，当在模板中使用时，ref 会自动解包 (有一些注意事项)。

**在模板中解包的注意事项:**
在模板渲染上下文中，只有顶级的 ref 属性才会被解包。

在下面的例子中，count 和 object 是顶级属性，但 object.id 不是：


```html
<template>
  <div>{{ count }} {{ object }} {{ object.id }}</div>
</template>
```

```js
<script>
import { ref } from 'vue'

export default {
  setup() {
    const count = ref(0)
    const object = ref({
      id: 1
    })

    return {
      count,
      object
    }
  }
}

{{ count + 1 }}  ✅
{{ object.id }}  ❌
</script>
```

```html
{{ object.id + 1 }}
```

渲染的结果将是 [object Object]1，因为在计算表达式时 object.id 没有被解包，仍然是一个 ref 对象。为了解决这个问题，我们可以将 id 解构为一个顶级属性：

```js
const { id } = object
{{ id + 1 }}
```

现在渲染的结果将是 2。

**`<script setup>`**

在 `setup()` 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用单文件组件 `(SFC)` 来避免这种情况。我们可以使用 `<script setup>` 来大幅度地简化代码：

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}
</script>

<template>
  <button @click="increment">
    {{ count }}
  </button>
</template>
```
**为什么要使用 ref？**
你可能会好奇：为什么我们需要使用带有 .value 的 ref，而不是普通的变量？为了解释这一点，我们需要简单地讨论一下 Vue 的响应式系统是如何工作的。

当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会追踪在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会触发追踪它的组件的一次重新渲染。

在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。

该 .value 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：


```javascript
// 伪代码，不是真正的实现
const myRef = {
  _value: 0,
  get value() {
    track()
    return this._value
  },
  set value(newValue) {
    this._value = newValue
    trigger()
  }
}
```

另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。

**深层响应性**
Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 Map。

Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：

```js
import { ref } from 'vue'

const obj = ref({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // 以下都会按照期望工作
  obj.value.nested.count++
  obj.value.arr.push('baz')
}
```

**DOM 更新时机**
当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓存所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。

要等待 DOM 更新完成后再执行额外的代码，可以使用 `nextTick()` 全局 API：

```js
import { nextTick } from 'vue'

async function increment() {
  count.value++
  await nextTick()
  // 现在 DOM 已经更新了
}
```

+ ##### **`reactive()`**
---

还有另一种声明响应式状态的方式，即使用 `reactive()` API。与将内部值包装在特殊对象中的 ref 不同，reactive() 将使对象本身具有响应性：

```js
import { reactive } from 'vue'

const state = reactive({ count: 0 })
```
在模板中使用：
```html
<button @click="state.count++">
  {{ state.count }}
</button>
```

`reactive()` 将 `深层地` 转换对象：当访问嵌套对象时，它们也会被 `reactive()` 包装。当 ref 的值是一个对象时，`ref()` 也会在内部调用它。与浅层 `ref` 类似，这里也有一个 `shallowReactive()` API 可以选择退出深层响应性。

**reactive() 的局限性:**

1.**有限的值类型：**它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。
2.**不能替换整个对象：**由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：
```js
let state = reactive({ count: 0 })
// 上面的 ({ count: 0 }) 引用将不再被追踪
// (响应性连接已丢失！)
state = reactive({ count: 1 })
```
3.对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接：
```js
const state = reactive({ count: 0 })
// 当解构时，count 已经与 state.count 断开连接
let { count } = state
// 不会影响原始的 state
count++
// 该函数接收到的是一个普通的数字
// 并且无法追踪 state.count 的变化
// 我们必须传入整个对象以保持响应性
callSomeFunction(state.count)
```

> **由于这些限制，我们建议使用 `ref()` 作为声明响应式状态的主要 API。**

##### ref 和 reactive 的区别
| api        | 定义     | 原理  | 数据支持 | 访问方式 | 设计需求 |
|-------------|---------|-------|-------------|---------|-------|
| ref |   用于创建`任何值`类型（基本类型或对象）的响应式引用，返回一个包含`.value`属性的对象   |     通过`getter/setter`劫持实现响应式，对象类型内部`自动调用reactive`转换。‌‌  | ref支持`所有类型`（如number、string、object） |`ref`需通过`.value`访问（模板中自动解包） | ref解决`单一值`的响应式需求|
| reactive | 仅适用于`对象类型`（对象、数组、Map/Set等），返回原始对象的`Proxy`代理 | 基于`Proxy递归劫持`对象属性，实现深层`响应式`。‌| reactive支持`对象类型` | reactive`直接访问属性` | `reactive`处理`复杂数据结构` |

> 1.`ref`简化基本类型响应式，`reactive` 优化对象操作（如嵌套属性直接修改）。‌
2.ref 包装对象时 内部 `依赖` reactive，两者`协同`工作。‌

#### 计算属性
模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：
```js
const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})
```

我们想根据 author 是否已有一些书籍来展示不同的信息：

```html
<p>Has published books:</p>
<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>
```

这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 `author.books`。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。

因此我们推荐使用`计算属性`来描述依赖响应式状态的复杂逻辑。这是重构后的示例：

```js
<script setup>
import { reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})

// 一个计算属性 ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})
</script>

<template>
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>

```

我们在这里定义了一个计算属性 `publishedBooksMessage`。`computed()` 方法期望接收一个 `getter` 函数，返回值为一个计算属性 `ref`。和其他一般的 ref 类似，你可以通过 `publishedBooksMessage.value` 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 `.value`。

Vue 的计算属性会自动追踪响应式依赖。它会检测到 `publishedBooksMessage` 依赖于 `author.books`，所以当 `author.books` 改变时，任何依赖于 `publishedBooksMessage` 的绑定都会同时更新。

##### 计算属性缓存 vs 方法
你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：

```html
<p>{{ calculateBooksMessage() }}</p>
```
```js
// 组件中
function calculateBooksMessage() {
  return author.books.length > 0 ? 'Yes' : 'No'
}
```
若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于**计算属性值会基于其响应式依赖被缓存**。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果，而不用重复执行 `getter` 函数。

这也解释了为什么下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖：
```js
const now = computed(() => Date.now())
```

相比之下，方法调用`总是`会在重渲染发生时再次执行函数。

为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 `list`，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 `list`。没有缓存的话，我们会重复执行非常多次 `list` 的 `getter`，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。

##### 可写计算属性
计算属性默认是`只读`的。当你尝试修改一个计算属性时，你会收到一个运行时`警告`。只在某些特殊场景中你可能才需要用到`“可写”`的属性，你可以通过同时提供 `getter` 和 `setter` 来创建：

```js
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```
现在当你再运行 `fullName.value = 'John Doe'` 时，`setter` 会被调用而 `firstName` 和 `lastName` 会随之更新。

##### 获取上一个值(仅 3.4+ 支持)
如果需要，可以通过访问计算属性的 getter 的第一个参数来获取计算属性返回的上一个值：

```js
<script setup>
import { ref, computed } from 'vue'

const count = ref(2)

// 这个计算属性在 count 的值小于或等于 3 时，将返回 count 的值。
// 当 count 的值大于等于 4 时，将会返回满足我们条件的最后一个值
// 直到 count 的值再次小于或等于 3 为止。
const alwaysSmall = computed((previous) => {
  if (count.value <= 3) {
    return count.value
  }

  return previous
})
</script>
```
如果你正在使用可写的计算属性的话：

```js
<script setup>
import { ref, computed } from 'vue'

const count = ref(2)

const alwaysSmall = computed({
  get(previous) {
    if (count.value <= 3) {
      return count.value
    }

    return previous
  },
  set(newValue) {
    count.value = newValue * 2
  }
})
</script>
```
> **避免直接修改计算属性值​**
从计算属性返回的值是`派生状态`。可以把它看作是一个`“临时快照”`，每当源状态发生变化时，就会创建一个新的快照。更改`快照`是没有意义的，因此计算属性的返回值应该被视为`只读的`，并且永远`不应该被更改`——应该更新它所依赖的源状态以触发新的计算。

#### Class 与 Style 绑定
##### class 绑定
###### 1. 绑定对象
---

```html
<div :class="{'active': isActive}"></div>
```
上面的语法表示 active 是否存在取决于数据属性 isActive 的真假值。

---

```js
const isActive = ref(true)
const hasError = ref(false)
<div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
></div>
```
result:

```html
<div class="static active"></div>
```
---
```js
const classObject = reactive({
  active: true,
  'text-danger': false
})
```
```html
<div :class="classObject"></div>
```
这将渲染：
```html
<div class="active"></div>
```
---
我们也可以绑定一个返回对象的`计算属性`。这是一个常见且很有用的技巧：
```js
const isActive = ref(true)
const error = ref(null)

const classObject = computed(() => ({
  active: isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal'
}))
```
```html
<div :class="classObject"></div>
```
result:
```html
<div class="active"></div>
```
---
###### 2. 绑定数组
我们可以给 :class 绑定一个数组来渲染多个 CSS class：
```js
const activeClass = ref('active')
const errorClass = ref('text-danger')
```
```html
<div :class="[activeClass, errorClass]"></div>
```
渲染的结果是：
```html
<div class="active text-danger"></div>
```
---
如果你也想在数组中有条件地渲染某个 class，你可以使用`三元表达式`：
```html
<div :class="[isActive ? activeClass : '', errorClass]"></div>
```
`errorClass` 会一直存在，但 `activeClass` 只会在 `isActive` 为真时才存在。

然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：
```html
<div :class="[{ [activeClass]: isActive }, errorClass]"></div>
```
---

##### style 绑定
###### 1. 绑定对象
`:style` 支持绑定 JavaScript 对象值，对应的是 `HTML 元素的 style 属性`：
```js
const activeColor = ref('red')
const fontSize = ref(30)
```
```html
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```
直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：
```js
const styleObject = reactive({
  color: 'red',
  fontSize: '30px'
})
```

```html
<div :style="styleObject"></div>
```
###### 2. 绑定数组
我们还可以给 :style 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：
```html
<div :style="[baseStyles, overridingStyles]"></div>
```
#### 条件渲染
##### v-if
##### v-else
##### v-else-if
##### `<template>` 上的 v-if
因为 v-if 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 <template> 元素上使用 v-if，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 <template> 元素。

```html
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
```

`v-else` 和 `v-else-if` 也可以在 `<template>` 上使用。

##### v-show
> v-show 不支持在 `<template>` 元素上使用，也不能和 v-else 搭配使用。

##### v-if vs v-show​
v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。
v-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。
相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。
总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。

##### v-if 和 v-for(优先级和V2 有区别)
当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。

#### 侦听器 - watch()
---
计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。

在组合式 API 中，我们可以使用 `watch` 函数在每次响应式状态发生变化时触发回调函数：

```js
<script setup>
import { ref, watch } from 'vue'

const question = ref('')
const answer = ref('Questions usually contain a question mark. ;-)')
const loading = ref(false)

// 可以直接侦听一个 ref
watch(question, async (newQuestion, oldQuestion) => {
  if (newQuestion.includes('?')) {
    loading.value = true
    answer.value = 'Thinking...'
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Error! Could not reach the API. ' + error
    } finally {
      loading.value = false
    }
  }
})
</script>

<template>
  <p>
    Ask a yes/no question:
    <input v-model="question" :disabled="loading" />
  </p>
  <p>{{ answer }}</p>
</template>
```
##### 数据源类型
watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：

```js
const x = ref(0)
const y = ref(0)

// 单个 ref
watch(x, (newX) => {
  console.log(`x is ${newX}`)
})

// getter 函数
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`sum of x + y is: ${sum}`)
  }
)

// 多个来源组成的数组
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x is ${newX} and y is ${newY}`)
})
```
> 注意，你不能直接侦听响应式对象的属性值，例如:

```js
const obj = reactive({ count: 0 })

// 错误，因为 watch() 得到的参数是一个 number
watch(obj.count, (count) => {
  console.log(`Count is: ${count}`)
})
```
这里需要用一个返回该属性的 getter 函数：

```js
// 提供一个 getter 函数
watch(
  () => obj.count,
  (count) => {
    console.log(`Count is: ${count}`)
  }
)
```
##### 深层侦听器 - deep (3.5 及以上版本)
直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：
```js
const obj = reactive({ count: 0 })

watch(obj, (newValue, oldValue) => {
  // 在嵌套的属性变更时触发
  // 注意：`newValue` 此处和 `oldValue` 是相等的
  // 因为它们是同一个对象！
})

obj.count++
```
相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：
```js
watch(
  () => state.someObject,
  () => {
    // 仅当 state.someObject 被替换时触发
  }
)
```
你也可以给上面这个例子显式地加上 `deep` 选项，强制转成深层侦听器：
```js
watch(
  () => state.someObject,
  () => {
    // 仅当 state.someObject 被替换时触发
  },
  { deep: true }
)
```
在 `Vue 3.5+` 中，deep 选项还可以是一个数字，表示最大遍历深度——即 Vue 应该遍历对象嵌套属性的级数。
##### 即时回调的侦听器​ - immediate
watch 默认是`懒执行`的：仅当`数据源变化`时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，`立即执行`一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。

我们可以通过传入 `immediate: true` 选项来强制侦听器的回调立即执行：

```js
watch(
  source,
  (newValue, oldValue) => {
    // 立即执行，且当 `source` 改变时再次执行
  },
  { immediate: true }
)
```

##### 一次性侦听器 - once (3.4 及以上版本)
每当被侦听源发生变化时，侦听器的回调就会执行。如果希望回调只在源变化时触发一次，请使用 `once: true` 选项。

```js
watch(
  source,
  (newValue, oldValue) => {
    // 当 `source` 变化时，仅触发一次
  },
  { once: true }
)
```

##### watchEffect()
侦听器的回调使用与源完全相同的响应式状态是很常见的。例如下面的代码，在每当 `todoId` 的引用发生变化时使用侦听器来加载一个远程资源：

```js
const todoId = ref(1)
const data = ref(null)

watch(
  todoId,
  async () => {
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
    )
    data.value = await response.json()
  },
  { immediate: true }
)
```
特别是注意侦听器是如何两次使用 `todoId` 的，一次是作为`源`，另一次是在`回调中`。

我们可以用 `watchEffect` 函数 来简化上面的代码。`watchEffect()` 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：

```js
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})
```
这个例子中，回调会立即执行，不需要指定 `immediate: true`。在执行期间，它会自动追踪 `todoId.value` 作为依赖(和计算属性类似)。每当 `todoId.value` 变化时，回调会再次执行。有了 `watchEffect()`，我们不再需要明确传递 `todoId` 作为源值。

对于这种只有一个依赖项的例子来说，`watchEffect()` 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 `watchEffect()` 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，`watchEffect()` 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。

##### watch vs watchEffect
`watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：
+ `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。`watch `会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
+ `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。

##### 副作用清理
有时我们可能会在侦听器中执行副作用，例如异步请求：
```js
watch(id, (newId) => {
  fetch(`/api/${newId}`).then(() => {
    // 回调逻辑
  })
})
```
但是如果在请求完成之前 id 发生了变化怎么办？当上一个请求完成时，它仍会使用已经过时的 ID 值触发回调。理想情况下，我们希望能够在 id 变为新值时取消过时的请求。

我们可以使用 `onWatcherCleanup() (3.5+) ` API 来注册一个清理函数，当侦听器失效并准备重新运行时会被调用：
```js
import { watch, onWatcherCleanup } from 'vue'

watch(id, (newId) => {
  const controller = new AbortController()

  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // 回调逻辑
  })

  onWatcherCleanup(() => {
    // 终止过期请求
    controller.abort()
  })
})
```
请注意，`onWatcherCleanup` 仅在 Vue 3.5+ 中支持，并且必须在 `watchEffect` 效果函数或 `watch` 回调函数的同步执行期间调用：你不能在异步函数的 `await` 语句之后调用它。

作为替代，`onCleanup` 函数还作为第三个参数传递给侦听器回调，以及 `watchEffect` 作用函数的第一个参数：

```js
watch(id, (newId, oldId, onCleanup) => {
  const controller = new AbortController()

  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // 回调逻辑
  })

  onCleanup(() => {
    // 终止过期请求
    controller.abort()
  })
})
```
或者，如果你使用的是 `watchEffect`：

```js
watchEffect((onCleanup) => {
  const controller = new AbortController()

  fetch(`/api/${id.value}`, { signal: controller.signal }).then(() => {
    // 回调逻辑
  })

  onCleanup(() => {
    // 终止过期请求
    controller.abort()
  })
})
```
这在 3.5 之前的版本有效。此外，通过函数参数传递的 `onCleanup` 与侦听器实例相绑定，因此不受 `onWatcherCleanup` 的同步限制。

#### 模板引用

---

虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 ref attribute：

```html
<input ref="input">
```
`ref` 是一个特殊的 attribute。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。

##### 访问模板引用
要在组合式 API 中获取引用，我们可以使用辅助函数 `useTemplateRef() (3.5+)`

```js
<script setup>
import { useTemplateRef, onMounted } from 'vue'

// 第一个参数必须与模板中的 ref 值匹配
const input = useTemplateRef('my-input')

onMounted(() => {
  input.value.focus()
})
</script>

<template>
  <input ref="my-input" />
</template>
```
`3.5 之前`的版本，
在 3.5 之前的版本尚未引入 `useTemplateRef()`，我们需要声明一个与模板里 ref attribute 匹配的引用：
```js
<script setup>
import { ref, onMounted } from 'vue'

// 声明一个 ref 来存放该元素的引用
// 必须和模板里的 ref 同名
const input = ref(null)

onMounted(() => {
  input.value.focus()
})
</script>

<template>
  <input ref="input" />
</template>
```
如果不使用 `<script setup>`，需确保从 `setup()` 返回 ref：

```js
export default {
  setup() {
    const input = ref(null)
    // ...
    return {
      input
    }
  }
}
```
注意，你只可以在组件挂载后才能访问模板引用。如果你想在模板中的表达式上访问 input，在初次渲染时会是 null。这是因为在初次渲染前这个元素还不存在呢！

如果你需要侦听一个模板引用 ref 的变化，确保考虑到其值为 null 的情况：
```js
watchEffect(() => {
  if (input.value) {
    input.value.focus()
  } else {
    // 此时还未挂载，或此元素已经被卸载(例如通过 v-if 控制)
  }
})
```

##### 组件上的 ref
模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例：

```js
<script setup>
import { useTemplateRef, onMounted } from 'vue'
import Child from './Child.vue'

const childRef = useTemplateRef('child')

onMounted(() => {
  // childRef.value 将持有 <Child /> 的实例
})
</script>

<template>
  <Child ref="child" />
</template>
```

3.5 之前的版本，
```js
<script setup>
import { ref, onMounted } from 'vue'
import Child from './Child.vue'

const child = ref(null)

onMounted(() => {
  // child.value 是 <Child /> 组件的实例
})
</script>

<template>
  <Child ref="child" />
</template>
```
如果一个子组件使用的是选项式 API 或没有使用 `<script setup>`，被引用的组件实例和该子组件的 `this` 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。

有一个例外的情况，使用了 `<script setup>` 的组件是默认私有的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏显式暴露：

```js
<script setup>
import { ref } from 'vue'

const a = 1
const b = ref(2)

// 像 defineExpose 这样的编译器宏不需要导入
defineExpose({
  a,
  b
})
</script>
```

当父组件通过模板引用获取到了该组件的实例时，得到的实例类型为 { a: number, b: number } (ref 都会自动解包，和一般的实例一样)。

> 请注意，`defineExpose` 必须在任何 `await` 操作之前调用。否则，在 `await` 操作后暴露的属性和方法将无法访问

#### 生命周期
##### 生命周期钩子函数

<img src="/images/img-folder/vue-smzq.png">

| 生命周期名称                | 描述                                                                                                        |
| :------------------------------------------             | :---------------------------------------------------------------------------------------------------------- |
| setup           | 组件初始化时调用，在 beforeCreate 和 created 之前调用，只能使用 Composition API 相关的函数，不能使用 this。 |
| onBeforeMount   | 组件挂载之前调用，在 mounted 之前调用，不能使用 this。                                                      |
| onMounted       | 组件挂载完成后调用，在 mounted 之后调用，不能使用 this。                                                    |
| onBeforeUpdate  | 组件更新之前调用，在 updated 之前调用，不能使用 this。                                                      |
| onUpdated       | 组件更新完成后调用，在 updated 之后调用，不能使用 this。                                                    |
| onBeforeUnmount | 组件卸载之前调用，在 unmounted 之前调用，不能使用 this。                                                    |
| onUnmounted     | 组件卸载完成后调用，在 unmounted 之后调用，不能使用 this。                                                  |
| `onRenderTracked` <sup>dev-only</sup>    | 注册一个调试钩子，当组件渲染过程中追踪到响应式依赖时调用。**这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。**                                          |
| `onRenderTriggered` <sup>dev-only</sup>     | 注册一个调试钩子，当响应式依赖的变更触发了组件渲染时调用。**这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。**                                          |
| `onActivated`     | 注册一个回调函数，若组件实例是 `<KeepAlive>` 缓存树的一部分，当组件被插入到 DOM 中时调用。**这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。**                                          |
| `onDeactivated`     | 注册一个回调函数，若组件实例是 `<KeepAlive>` 缓存树的一部分，当组件从 DOM 中被移除时调用。**这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。**                                          |
| `onServerPrefetch` <sup>SSR only</sup>    | 注册一个异步函数，在组件实例在服务器上被渲染之前调用。|

#### props
一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props。

##### defineProps()

在使用 `<script setup>` 的单文件组件中，`props` 可以使用 `defineProps()` 宏来声明：

```js
<script setup>
const props = defineProps(['foo'])

console.log(props.foo)
</script>
```

在没有使用 `<script setup>` 的组件中，`props` 可以使用 `props` 选项来声明：

```js
export default {
  props: ['foo'],
  setup(props) {
    // setup() 接收一个上下文对象，其中包含组件的 props
    console.log(props.foo)
  }
}
```
注意传递给 `defineProps()` 的参数和提供给 `props` 选项的值是相同的，两种声明方式背后其实使用的都是 `props` 选项。

除了使用字符串数组来声明 `props` 外，还可以使用`对象`的形式：

```js
// 使用 <script setup>
const props = defineProps({
  itemData: {
    type: Object
  },
  index: Number,
  showRank: {
    type: Boolean,
    default: false
  },
  rank: {
    type: Number,
    default: 0
  }
})
defineProps({
  title: String,
  likes: Number
})
// 非 <script setup>
export default {
  props: {
    title: String,
    likes: Number
  }
}
<script setup lang="ts">
defineProps<{
  title?: string
  likes?: number
}>()
</script>
```
#### 事件
##### 触发与监听事件
在组件的模板表达式中，可以直接使用 `$emit` 方法触发自定义事件 (例如：在 `v-on` 的处理函数中)：

```html
<!-- MyComponent -->
<button @click="$emit('someEvent')">Click Me</button>
```
在父组件中监听这个事件：

```html
<MyComponent @some-event="callback" />
```
在父组件中，可以通过 `v-on` 或 `@` 来监听子组件触发的事件。事件名需要和子组件 `$emit` 的名称完全匹配。

##### 事件参数

```js
<button @click="$emit('increaseBy', 1)">
  Increase by 1
</button>
```

```html
<MyButton @increase-by="(n) => count += n" />
```

或者是
```html
<MyButton @increase-by="increaseCount" />
```
```js
function increaseCount(n) {
  count.value += n
}
```

> 注意：所有传入 $emit() 的额外参数都会被直接传向监听器。举例来说，$emit('foo', 1, 2, 3) 触发后，监听器函数将会收到这三个参数值。

##### 声明触发的事件 - defineEmits()

组件可以显式地通过 `defineEmits()` 宏来声明它要触发的事件：

**父组件**
```html
<tab-r id="tab15" @open="open"></tab-r>
<uni-popup ref="popup" type="bottom" border-radius="10px 10px 0 0">
  <view style="padding: 40rpx;background: #fff;" class="popup-content">
    <text>人生若只如初见，何事秋风悲画扇</text>
  </view>
</uni-popup>
```
```js
const open = async () => {
  try {
    // 等待DOM更新
    await nextTick()

    if (popup.value && popup.value.open) {
      popup.value.open('bottom')
      console.log('uni-popup opened successfully')
    } else {
      console.error('uni-popup ref not found')
    }
  } catch (error) {
    console.error('Failed to open popup:', error)
  }
}
```
**子组件**  `tab-r`子组件
```html
<view class="university-info-bottom-item" @click="openFn">
  <text class="num">66</text>
  <view class="university-info-bottom-item-text">
    <text>开学率</text>
    <up-icon name="info-circle" color="#333" size="12"></up-icon>
  </view>
</view>
```
```js
const emits = defineEmits(['open'])
const openFn = () => {
  emits('open', 1111)
}
```
##### 事件校验
```js
<script setup>
const emit = defineEmits({
  // 没有校验
  click: null,

  // 校验 submit 事件
  submit: ({ email, password }) => {
    if (email && password) {
      return true
    } else {
      console.warn('Invalid submit event payload!')
      return false
    }
  }
})

function submitForm(email, password) {
  emit('submit', { email, password })
}
</script>
```
#### 组件 v-model - defineModel()
`v-model` 可以在组件上使用以实现双向绑定。
从 Vue 3.4 开始，推荐的实现方式是使用 `defineModel()` 宏：

```html
<!-- Child.vue -->
<script setup>
const model = defineModel()

function update() {
  model.value++
}
</script>

<template>
  <div>Parent bound v-model is: {{ model }}</div>
  <button @click="update">Increment</button>
</template>
```
父组件可以用 v-model 绑定一个值：

```html
<!-- Parent.vue -->
<Child v-model="countModel" />
```
`defineModel()` 返回的值是一个 ref。它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用：

+ 它的 .value 和父组件的 v-model 的值同步；
+ 当它被子组件变更了，会触发父组件绑定的值一起更新。

这意味着你也可以用 `v-model` 把这个 ref 绑定到一个原生 input 元素上，在提供相同的 `v-model` 用法的同时轻松包装原生 input 元素：
```html
<!-- app.vue -->
<script setup>
import Child from './Child.vue'
import { ref } from 'vue'

const msg = ref('Hello World!')
</script>

<template>
  <h1>{{ msg }}</h1>
  <Child v-model="msg" />
</template>

```
```html
<!-- Child.vue -->
<script setup>
const model = defineModel()
</script>

<template>
  <span>My input</span> <input v-model="model">
</template>
```
##### 底层机制
`defineModel` 是一个便利宏。编译器将其展开为以下内容：

+ 一个名为 modelValue 的 prop，本地 ref 的值与其同步；
+ 一个名为 update:modelValue 的事件，当本地 ref 的值发生变更时触发。

在 3.4 版本之前，你一般会按照如下的方式来实现上述相同的子组件：
```html
<!-- Child.vue -->
<script setup>
const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])
</script>

<template>
  <input
    :value="props.modelValue"
    @input="emit('update:modelValue', $event.target.value)"
  />
</template>
```
然后，父组件中的 `v-model="foo"` 将被编译为：
```html
<!-- parent.vue -->
<Child
  :modelValue="foo"
  @update:modelValue="$event => (foo = $event)"
/>
```
##### v-model 的参数
```html
<!-- parent.vue -->
<script setup>
import { ref } from 'vue'
import MyComponent from './MyComponent.vue'
  
const bookTitle = ref('v-model argument example')
</script>

<template>
  <h1>{{ bookTitle }}</h1>
  <MyComponent v-model:title="bookTitle" />
</template>
```

```html
<!-- MyComponent.vue -->
<script setup>
const title = defineModel('title')
</script>

<template>
  <input type="text" v-model="title" />
</template>
```
##### 多个 v-model 绑定
```html
<!-- parent.vue -->
<UserName
  v-model:first-name="first"
  v-model:last-name="last"
/>
```
```html
<!-- UserName.vue -->
<script setup>
const firstName = defineModel('firstName')
const lastName = defineModel('lastName')
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
</template>
```
##### 处理 v-model 修饰符
我们来创建一个自定义的修饰符 `capitalize`，它会自动将 `v-model` 绑定输入的字符串值第一个字母转为大写：

```html
<script setup>
import { ref } from 'vue'
import MyComponent from './MyComponent.vue'
  
const myText = ref('')
</script>

<template>
  This input capitalizes the first letter you enter:
  <MyComponent v-model.capitalize="myText" />
</template>
```
```js
// MyComponent.vue
const [model, modifiers] = defineModel({
  set(value) {
    if (modifiers.capitalize) {
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
    return value
  }
})
</script>

<template>
  <input type="text" v-model="model" />
</template>
```

##### 带参数的 v-model 修饰符​
```html
<UserName
  v-model:first-name.capitalize="first"
  v-model:last-name.uppercase="last"
/>
```
```js
<script setup>
const [firstName, firstNameModifiers] = defineModel('firstName')
const [lastName, lastNameModifiers] = defineModel('lastName')

console.log(firstNameModifiers) // { capitalize: true }
console.log(lastNameModifiers) // { uppercase: true }
</script>
```
#### 透传 Attributes

“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 `props` 或 `emits` 的 `attribute` 或者 `v-on` 事件监听器。最常见的例子就是 `class``、style` 和 `id`。

当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。举例来说，假如我们有一个 `<MyButton>` 组件，它的模板长这样：

```html
<!-- <MyButton> 的模板 -->
<button>Click Me</button>
```
一个父组件使用了这个组件，并且传入了 `class`：
```html
<MyButton class="large" />
```
最后渲染出的 DOM 结果是：
```html
<button class="large">Click Me</button>
```
这里，`<MyButton>` 并没有将 `class` 声明为一个它所接受的 prop，所以 `class` 被视作透传 attribute，自动透传到了 `<MyButton>` 的根元素上。

##### 对 class 和 style 的合并

如果一个子组件的根元素已经有了 class 或 style attribute，它会和从父组件上继承的值合并。如果我们将之前的 `<MyButton>` 组件的模板改成这样：
```html
<!-- <MyButton> 的模板 -->
<button class="btn">Click Me</button>
```
则最后渲染出的 DOM 结果会变成：
```html
<button class="btn large">Click Me</button>
```
##### v-on 监听器继承

同样的规则也适用于 `v-on` 事件监听器：
```html
<MyButton @click="onClick" />
```
`click` 监听器会被添加到 `<MyButton>` 的根元素，即那个原生的 `<button>` 元素之上。当原生的 `<button>` 被点击，会触发父组件的 `onClick` 方法。同样的，如果原生 `button` 元素自身也通过 `v-on` 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。

##### 深层组件继承
有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 `<MyButton>`，让它在根节点上渲染 `<BaseButton>`：
```html
<!-- <MyButton/> 的模板，只是渲染另一个组件 -->
<BaseButton />
```
此时 `<MyButton>` 接收的透传 attribute 会直接继续传给` <BaseButton>`。

> 请注意：
 > + 透传的 `attribute` 不会包含 `<MyButton>` 上声明过的 `props` 或是针对 `emits` 声明事件的 `v-on` 侦听函数，换句话说，声明过的 `props` 和侦听函数被 `<MyButton>`“消费”了。
> + 透传的 `attribute` 若符合声明，也可以作为 `props` 传入 `<BaseButton>`。

----

##### 禁用 Attributes 继承
如果你**不想要**一个组件自动地继承 attribute，你可以在组件选项中设置 `inheritAttrs: false`。
从 `3.3` 开始你也可以直接在 `<script setup>` 中使用 `defineOptions`：
```html
<script setup>
defineOptions({
  inheritAttrs: false
})
// ...setup 逻辑
</script>
```
最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 `inheritAttrs` 选项为 `false`，你可以完全控制透传进来的 attribute 被如何使用。

这些透传进来的 attribute 可以在模板的表达式中直接用 `$attrs` 访问到。
```html
<span>Fallthrough attribute: {{ $attrs }}</span>
```

这个 `$attrs` 对象包含了除组件所声明的 `props` 和 `emits` 之外的所有其他 attribute，例如 `class`，`style`，`v-on` 监听器等等。

> 有几点需要注意：
  > + 和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 `foo-bar` 这样的一个 attribute 需要通过 `$attrs['foo-bar']` 来访问。
  > + 像 `@click` 这样的一个 `v-on` 事件监听器将在此对象下被暴露为一个函数 `$attrs.onClick`。

现在我们要再次使用一下之前小节中的 `<MyButton>` 组件例子。有时候我们可能为了样式，需要在 `<button>` 元素外包装一层 `<div>`：
```html
<div class="btn-wrapper">
  <button class="btn">Click Me</button>
</div>
```
我们想要所有像 `class` 和 `v-on` 监听器这样的透传 attribute 都应用在内部的 `<button>` 上而不是外层的 <`div>` 上。我们可以通过设定 `inheritAttrs: false` 和使用 `v-bind="$attrs"` 来实现：
```html
<div class="btn-wrapper">
  <button class="btn" v-bind="$attrs">Click Me</button>
</div>
```

> 小提示：没有参数的 `v-bind` 会将一个对象的所有属性都作为 attribute 应用到目标元素上。如一下例子：

如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：
```js
const objectOfAttrs = {
  id: 'container',
  class: 'wrapper',
  style: 'background-color:green'
}
```
通过不带参数的 `v-bind`，你可以将它们绑定到单个元素上：
```html
<div v-bind="objectOfAttrs"></div>
```

##### 多个根节点的 Attributes 继承
和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 `$attrs` 没有被显式绑定，将会抛出一个运行时警告。
```html
<CustomLayout id="custom-layout" @click="changeValue" />
```
如果 `<CustomLayout>` 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。
```html
<header>...</header>
<main>...</main>
<footer>...</footer>
```
如果 `$attrs` 被显式绑定，则不会有警告：
```html
<header>...</header>
<main v-bind="$attrs">...</main>
<footer>...</footer>
```

##### 在 JavaScript 中访问透传 Attributes - useAttrs()
如果需要，你可以在 `<script setup>` 中使用 `useAttrs()` API 来访问一个组件的所有透传 attribute：
```js
<script setup>
import { useAttrs } from 'vue'

const attrs = useAttrs()
</script>
```

如果没有使用 `<script setup>`，`attrs` 会作为 `setup()` 上下文对象的一个属性暴露：
```js
export default {
  setup(props, ctx) {
    console.log(ctx.attrs)
  }
}
```
> 需要注意的是，虽然这里的 `attrs` 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用 `onUpdated()` 使得在每次更新时结合最新的 `attrs` 执行副作用。

#### 插槽 Slots
##### 插槽内容与出口

