---
title: 红皮书第六章-面向对象的设计程序
categories: jc-end
date: 2020-08-04 10:10:43
---
### 属性类型
#### 数据属性(Object.defineProperty())
1) [[Configurable]]: 表示能否通过delete删除属性，从而重新定义属性，，默认值为true    
2) [[Enumerable]]: 表示能否通过for-in循环返回属性，，默认值为true    
3) [[Writable]]: 表示能否修改属性的值，，默认值为true    
4) [[Value]]: 包含这个属性的值，默认值为undefined    

> 修改对象属性的默认特性，必须使用Object.defineProperty()方法。

<!-- more -->
```javascript
var person = {}
Object.defineProperty(person, 'name', {
  writable: false,
  value: 'ceshi'
})
console.log(person.name) // ceshi
person.name = "xiugai"
console.log(person.name) // ceshi
```
#### 访问器属性(getter 和 setter函数)   
访问器属性不包含数据值，他们包含一对getter 和 setter函数，在读取访问器属性值得时候，会调用getter函数，在写入访问器属性的时候，调用setter函数。    

1) [[Configurable]]: 表示能否通过delete删除属性，从而重新定义属性，，默认值为true    
2) [[Enumerable]]: 表示能否通过for-in循环返回属性，，默认值为true    
3) [[Get]]: 在读取属性的时调用的函数，默认值为undefined  
4) [[Set]]: 在写入属性的时调用的函数，默认值为undefined   

> 访问器属性不能直接定义，必须使用Object.defineProperty()方法来定义。

```javascript
var book = {
  _year: 2004,
  edition: 1
}
Object.defineProperty(book, 'year', {
  get: function(){
    return this._year
  },
  set: function (newValue) {
    if (newValue > 2004) {
      this._year = newValue;
      this.edition += newValue - 2004;
    }
  }
})
book.year = 2005;
console.log(book.edition) // 2
console.log(book._year) // 2005
console.log(book.year) // 2005
```
> 不一定同时指定getter和setter函数，只指定getter函数，意味着属性是不能写的。   

#### 定义多个属性(Object.defineProperties())
由于定义对象多个属性的可能性很大，所以ECMCscript5又定义了defineProperties()方法，利用这个方法可以通过描述符定义多个属性。
```javascript
var book = {}
Object.defineProperties(book, {
  _year: {
    value: 2004
  },
  edition: {
    value: 1
  },
  year: {
    get: function() {
      return this._year
    },
    set: function (newValue) {
      if (newValue > 2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
})
```
#### 读取属性的特性(Object.getOwnPropertyDescriptor())
```javascript
var book = {}
Object.defineProperties(book, {
  _year: {
    value: 2004
  },
  edition: {
    value: 1
  },
  year: {
    get: function() {
      return this._year
    },
    set: function (newValue) {
      if (newValue > 2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
})
var descriptor = Object.getOwnPropertyDescriptor(book, "_year")
console.log(descriptor.value) // 2004
console.log(descriptor.configurable) // false
console.log(typeof descriptor.get) //undefined
var descriptor1 = Object.getOwnPropertyDescriptor(book, "year")
console.log(descriptor1.value) //undefined
console.log(descriptor1.enumerable) //false
console.log(typeof descriptor1.get) //function
```
### 创建对象
已知的创建对象，有构造函数和字面量来创建单个对象，但是用同一个接口来创建多个对象的话，就会产生大量重复的代码，为解决这个问题，人们开始使用工厂模式的一种变体。    
#### 工厂模式
```javascript
function createPerson(name, age, job){
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function (){
    console.log(o.name)
  };
  return o;
}
var person1 = createPerson('a', 29, 'teacher')
var person2 = createPerson('b', 19, 'doctor')
```
> 工厂模式解决了创建对象产生大量重复代码的问题，但是没有解决对象识别的问题（即怎么知道一个对象的类型），这个方法构造函数模式解决了这个问题。

#### 构造函数模式
```javascript
function Person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function (){
    console.log(this.name)
  };
}
var person1 = new Person('a', 29, 'teacher')
var person2 = new Person('b', 19, 'doctor')
console.log(person1.constructor == Person) // true
console.log(person2.constructor == Person) // true
console.log(person1 instanceof Object) // true
console.log(person1 instanceof Person) // true
```
> 1.构造函数名第一个字母是大写的，这个是用来区分普通函数。
> 2.创建自定义的构造函数意味着将来可以将它的实例标识作为一种特定的类型。  

##### 将构造函数当做函数
```javascript
// 作为构造函数
var person1 = new Person('a', 29, 'teacher')
person1.sayName() // a
// 作为普通函数
Person('a',  29, 'teacher')
window.sayName() // a
// 在另一个对象的作用域中调用
var o = new Object()
Person.call(o, 'a', 29, 'teacher')
o.sayName() // a
```
##### 构造函数的问题
构造函数的主要问题，就是每一个实例，都重新创建了一次构造函数的方法，比如下方例子
```javascript
var person1 = new Person('a', 29, 'teacher')
var person2 = new Person('b', 19, 'doctor')
console.log(person1.sayName == person2.sayName) // false
```
通过把函数定义到对象的外部，可以解决这个问题。
```javascript
function Person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName
}
function sayName(){
  console.log(this.name)
};
var person1 = new Person('a', 29, 'teacher')
var person2 = new Person('b', 19, 'doctor')
console.log(person1.sayName == person2.sayName) // true
```
> 将函数放到对象的外部，也就是全局环境中，this.sayName就相当于一个指针，person1,person2实例sayName指针指向了同一个方法，就实现了每一个实例不需要再去创建每一个方法，但是这样有一个坏处就是所有的方法放到全局作用域中，一定程度上污染了全局作用域，好在这个问题可以用原型模式来解决。

#### 原型模式
我们创建的每个函数都有一个 prototype (原型)属性,这个属性是一个指针,指向一个对象,而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解,那么 prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原烈对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说,不必在构造函数中定义对象实例的信息,而是可以将这些信息直接添加到原型对象中,如下面的例子所示。
```javascript
function Person(){}
Person.prototype.name = 'Nicholas'
Person.prototype.age = 29
Person.prototype.job = 'software Engineer'
Person.prototype.sayName = function() {
  console.log(this.name)
}
var person1 = new Person()
var person2 = new Person()
console.log(person1.sayName === person2.sayName) // true
```
##### 理解原型对象
![blockchain](https://raw.githubusercontent.com/xiaosongread/github-xiaosongread-hexo/master/img-folder/hps/5/2.png)    

图6-1展示了 Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。在此, Pereon.prototype指向了原型对象,而 Person.prototype. constructor又指回了Person。原型对象中除了包含constructor属性之外,还包括后来添加的其他属性。Person的每个实例person1和pereon2都包含一个内部属性,该属性仅仅指向了Person.prototype；换句话说, 它们与构造函数没有直接的关系。此外,要格外注意的是,虽然这两个实例都不包含属性和方法,但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。   

###### getPrototypeOf()：获取对象的原型
```javascript
console.log(Object.getPrototypeOf(person1) == Person.prototype) // true
console.log(Object.getPrototypeOf(person1).name) // Nicholas
```

